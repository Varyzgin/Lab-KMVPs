# Варызгин Дмитрий
# Задание 11_4
import matplotlib.pyplot as plt
import scipy.stats as st
import numpy as np
np.set_printoptions(precision=3)

# Биномиальный закон распределения
N = 100  # серии
k = 1  # число кубиков
n = 4  # число бросков
p = 1 / (6 ** k)  # шанс выпадения шестерки на k кубиках

# БРОСАЕМ РЕАЛЬНО КУБИКИ
    # рандомное моделирование конкретных значений x[i] (считай, бросили - записали)
    # массив - матрица размера N на n (где строка - серия из 4 бросков)
X = np.random.uniform(0, 1, [N, n])
    # print(X)
    # // делим [0, 1] на 6 равных частей: выпадение 6ки = [0, 1/6), 5ки - [1/6, 2/6) ...
m1 = np.sum(X < p, axis=1)
    # m1 - массив (длины, равной кол-ву серий) который содержит числА: сколько раз выпала 6ка в 1 серии (строке) (ни разу, 1, 2, 3 или всегда)
    # т.е числа из интервала [0, 1/6), иначе говоря - меньших p
P = []  # массив из 5 эл-в для относительных частот 0, 1, 2, 3 или 4х выпадений 6к
for i in range(n + 1):
    # смотрим, сколько раз выпала 6ка: 0, 1, 2, 3, или 4 раза (поэтому значений на 1 больше, чем число бросков)
    m = np.sum(m1 == i)  # абсолютная частота
        # i = 0: ищем сколько раз ни разу не выпала 6ка (0 / 4) (то бишь считаем сколько нулей в массиве m1 (m1 == i))
        # i = 1: ищем сколько раз 1 раз выпала 6ка (1 / 4) (то бишь считаем сколько 1 в массиве m1 (m1 == i))
        # ...
        # i = 4: ищем сколько раз везде выпала 6ка (4 / 4)
    P.append(m / N) # вычисление относительной частоты 
print(f'n = {i}, p = {p:.3f}, модел: отн. ч. = {P}')
print(f'{1 - P[0]} - Вероятность выпадения шестерки на 1 кубике при 4х бросках') # по формуле противополож. события: P(A) = 1 - P(не(А))
# ИСКУСТВЕННО: чисто параметры - нет привязки к чему-то реальному
x = np.arange(0, n + 1)
y = st.binom.pmf(x, n, p)

plt.plot(x, y, color = 'blue', label = 'С помощью scipy')
plt.vlines(x, 0, P, color = 'green')
plt.plot(x, P, 'o r', label = 'Распределение вручную')
plt.legend()
plt.show()

